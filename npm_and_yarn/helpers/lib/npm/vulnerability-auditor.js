/* Vulnerability auditor for npm
 *
 * Inputs:
 *  - directory containing a package.json and a package-lock.json
 *  - security advisories to audit for,
 *      [{"dependency_name": string, "affected_versions": [string]}]
 *
 * Outputs:
 *  - A report of vulnerable dependencies
 */

const Arborist = require("@npmcli/arborist")
const nock = require('nock')
const semver = require('semver')

// TODO: we observed when we passed several vuln ranges to the bulk endpoint,
// one range that was below installed version and two above it, the response
// indicated no vulns. Why? Do we need to filter out vuln ranges that don't
// include the installed version before passing them to this function?
async function findVulnerableDependencies(directory, advisoriesStr) {
  const advisories = JSON.parse(advisoriesStr)

  const arb = new Arborist({
    path: directory,
    auditRegistry: 'http://localhost:9999',
  })

  const scope = nock('http://localhost:9999')
    .post('/-/npm/v1/security/advisories/bulk')
    .reply(200, convertAdvisoriesToRegistryBulkFormat(advisories))

  if (!nock.isActive()) {
    nock.activate()
  }

  return await arb.audit()
    .then(report => {
      _debugReport(report)
      return buildResponseFromReport(advisories, tree, report.toJSON())
    })
    .catch(err => buildResponseFromError(advisories, err))
    .finally(() => {
      // TODO: is this correct cleanup?
      nock.cleanAll()
      nock.restore()
    })
}

// TODO: remove
function _debugReport(report) {
  console.log(`report is instance of ${report.constructor.name}`)
  console.log('report.keys()', report.keys())

  const name = 'webpack-dev-server'
  const vuln = report.get(name)

  console.log(`vuln is instance of ${vuln.constructor.name}`)
  console.log('vuln', vuln)
  console.log('vuln.range', vuln.range)
  console.log('vuln.simpleRange', vuln.simpleRange)
  console.log('vuln.fixAvailable', vuln.fixAvailable)

  const [node] = [...vuln.nodes].filter(n => n.name == name)
  console.log('vuln node.version', node.version)

  const [edgeIn] = node.edgesIn
  console.log('vuln node edgeIn.spec', edgeIn.spec)
  // If parent's range allows fix, vuln.testSpec() should return false
  console.log(`vuln.testSpec('${edgeIn.spec}')`, vuln.testSpec(edgeIn.spec))

  // vuln.testSpec(vuln.range) should return true
  const vulnSpec = vuln.range
  console.log(`vuln.testSpec('${vuln.range}')`, vuln.testSpec(vuln.range))

  return report
}

function convertAdvisoriesToRegistryBulkFormat(advisories) {
  return advisories.reduce((formattedAdvisories, advisory) => {
    if (!formattedAdvisories[advisory.dependency_name]) {
      formattedAdvisories[advisory.dependency_name] = []
    }
    let formattedVersions =
      advisory.affected_versions.reduce((memo, version) => {
        memo.push({ vulnerable_versions: version })
        return memo
      }, [])
    formattedAdvisories[advisory.dependency_name].push(...formattedVersions)
    return formattedAdvisories
  }, {})
}

function buildResponseFromError(advisories, err) {
  return {
    dependency_name: advisories[0].dependency_name,
    fix_available: false,
  }
}

function buildResponseFromReport(advisories, tree, report) {
  if (report.auditReportVersion !== 2) {
    // TODO: what if report was generated by a version other than 2?
  }

  if (report.metadata.vulnerabilities.total === 0) {
    // TODO: what if report says there are no vulns?
  }

  // @param name: string
  // @returns null | { dependency_name: string,
  //                   current_version: string,
  //                   target_version: string }
  const findFix = name => {
    let vuln = report.vulnerabilities[name]
    if (vuln?.fixAvailable !== true) {
      return null
    }

    const fix = {
      dependency_name: name,
      current_version: getCurrentVersion(tree, name),
      target_version: "",
    }

    for (const effect of vuln.effects) {
      const effectFix = findFix(effect)
      if (!effectFix) {
        return null
      }
      // TODO
    }
  }

  return report
}

module.exports = { findVulnerableDependencies }
